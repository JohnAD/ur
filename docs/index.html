<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="ur">ur</h1>
<h2 id="nim-universal-return-system">Nim Universal Return system</h2>
<p>A Universal Return (UR) is an object that allows the programmer to return either a value or a sequence of messages (or both) from a procedure. This could, of course, be done by hand using tuple or other options, but the goal of this package is two-fold:</p>
<ol style="list-style-type: decimal">
<li>Make it easy (and predictable) to create such &quot;dynamic&quot; returns.</li>
<li>Make it possible to integrate such a system with other libraries.</li>
</ol>
<table>
<thead>
<tr class="header">
<th align="left">Table of Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="#a-simple-example">A Simple Example</a></td>
</tr>
<tr class="even">
<td align="left"><a href="#library-example">Library Example</a></td>
</tr>
<tr class="odd">
<td align="left"><a href="#the-ur-object">The UR Object</a></td>
</tr>
<tr class="even">
<td align="left"><a href="#bonus-adding-detail">Bonus: Adding Detail</a></td>
</tr>
<tr class="odd">
<td align="left"><a href="#more-information">More Information</a></td>
</tr>
</tbody>
</table>
<h2 id="a-simple-example">A Simple Example</h2>
<p>The following is a very simple example of UR.</p>
<p>First, we are going to import the library and &quot;wrap&quot; the type of element we want to return.</p>
<pre class="nim"><code>import ur


type
  Vector = tuple[x: int, y: int]


wrap_UR(Vector)
</code></pre>
<p>The <code>wrap_UR</code> macro creates a <code>UR_Vector</code> object with large set of useful methods.</p>
<p>(Don't worry, with conditional compiling, Nim should later remove the methods you don't use.)</p>
<p>Now, we use the new object for returning a flexible result:</p>
<pre class="nim"><code>import ur


type
  Vector = tuple[x: float, y: float]


wrap_UR(Vector)

proc reduceXByNumber(v: Vector, denominator: float): UR_Vector =
  result = newUR_Vector()  # this procedure was generated by &#39;wrap_UR&#39;
  if denominator == 0.0:
    result.set_failure(&quot;You can&#39;t divide by zero; Ever&quot;)
    return
  if denominator == 0.0:
    result.set_failure(&quot;Negative denominators are not allowed&quot;)
    return
  if denominator &lt; 0.1:
    result.set_warning(&quot;That is an awefully small denominator&quot;)
  newVector = v
  newVector.x = newVector.x / denominator
  result.value = newVector
  result.set_expected_success(&quot;Vector x reduced&quot;)


# Now lets use it.

var a = Vector(4.0, 3.2)

var response = reduceXByNumber(a, 2.0)
if response.ok:
  echo &quot;my new x is &quot; &amp; $response.value.x

# should display:
#
# &gt; my new x is 2.0


response = reduceXByNumber(a, 0.0)
if not response.ok:
  echo &quot;error messages: &quot; &amp; $response

# should display:
#
# error messages:
#...... TODO

response = reduceXByNumber(a, 0.0001)
if response.ok:
  echo &quot;my new x is &quot; &amp; $response.value.x
if response.has_warnings:
  echo &quot;my warnings are &quot; &amp; $response.warnings

# should display:
#
#.....TODO

#

</code></pre>
<h2 id="library-example">Library Example</h2>
<p>Internally, UR has one library already integrated: Nim's standard <code>logging</code> module. You can use it by importing 'urpkg.log'.</p>
<p>For example:</p>
<pre class="nim"><code>import
  strutils,
  logging

import
  ur,
  urpkg.log


var L = newFileLogger(&quot;test.log&quot;, fmtStr = verboseFmtStr)
addHandler(L)


type
  Vector = tuple[x: float, y: float]


wrap_UR(Vector)

proc example(v: Vector): UR_Vector:
  result = newUR_Vector()
  result.value = v
  result.value.x = result.value.x + 1.0
  result.set_expected_success(&quot;x incremented by 1.0&quot;)

var a = Vector(x: 9.3, y: 3.0)

var response = a.example()

echo &quot;message: $1, x: $2&quot;.format(response.msg, response.value.x)

response.sendLog()  # this sends the event(s) to logging
</code></pre>
<p>Now &quot;test.log&quot; will have an entry similar to this:</p>
<pre class="log"><code>D, [2018-06-29T12:34:42] -- app: success; user; x incremented by 1.0</code></pre>
<p>All filtering for <code>sendLog</code> is done by <code>logging</code>; and that library strictly looks at the <code>level</code> attribute.</p>
<h2 id="the-ur-object">The UR Object</h2>
<p>UR is all about the automatically generate UR_<em>object</em> objects. The objects are defined internally as:</p>
<pre class="nim"><code>type

  URevent*
    msg*: string                     
    level*: Level                    
    class*: DisplayClass             
    audience*: Audience 

  UR_&lt;type&gt;
    events*: seq[URevent]
    value*: &lt;type&gt;</code></pre>
<p>So, essentially, there is a list of events (messages) and the value being returned.</p>
<p>Each event has a message and three very distinct attributes.</p>
<h3 id="level">level</h3>
<p>The <code>level</code> is the degree of distribution for the message.</p>
<p>It answers the question: <em>How Important is This?</em></p>
<p>The available levels:</p>
<ul>
<li><code>lvlAll</code></li>
<li><code>lvlDebug</code></li>
<li><code>lvlInfo</code></li>
<li><code>lvlNotice</code></li>
<li><code>lvlWarn</code></li>
<li><code>lvlError</code></li>
<li><code>lvlFatal</code></li>
<li><code>lvlNone</code></li>
</ul>
<p>The <code>level</code> definitions are set by the <code>logging</code> standard library that is part of Nim. See: https://nim-lang.org/docs/logging.html</p>
<p>NOTE: the names of the levels are somewhat misleading. Using a level of <code>lvlError</code> does NOT mean that an error has occured. It means <em>&quot;if I'm filtering a log for mostly errors, this message should show up in that log&quot;</em>.</p>
<p>For judging the character of the event, use the <code>class</code>.</p>
<h3 id="class">class</h3>
<p>The <code>class</code> is the judgement of the event.</p>
<p>it answers the question: <em>Is this a good or bad event?</em></p>
<p>Only four classes are possible:</p>
<ul>
<li><code>info</code> - a neutral message adding extra information</li>
<li><code>success</code> - everything worked</li>
<li><code>warning</code> - everything worked, but something is suspicious</li>
<li><code>danger</code> - failure/error/bug</li>
</ul>
<p>The <code>class</code> definitions are from the Boostrap CSS project. See: https://getbootstrap.com</p>
<h3 id="audience">audience</h3>
<p>The <code>audience</code> is, not surpisingly, the intended audience for any message about the event.</p>
<p>In a traditional 'logger' or SYSLOG system, the intended audience is strictly <code>ops</code>. UR allows for further targets; useful when UR is integrated with web apps or other development frameworks.</p>
<p>It answers the question: <em>Who is permitted to see This?</em></p>
<p>The possible audiences are:</p>
<ul>
<li><code>ops</code> - IT staff, developers, software agents</li>
<li><code>admin</code> - users with admin clearance</li>
<li><code>user</code> - regular end users / registered members</li>
<li><code>public</code> - the whole world (no restrictions)</li>
</ul>
<p>Each audience permission is more restrictive than the previous. So, <code>ops</code> can see all events. But <code>admin</code> can only see <code>admin</code>, <code>user</code> and <code>public</code> events. And so on.</p>
<h3 id="combining-the-attributes-together.">Combining the attributes together.</h3>
<p>The attributes are meant to be combined when making decisions.</p>
<p>For example, an event with an <code>audience</code> of <code>user</code> but a <code>level</code> of <code>lvlDebug</code> probably won't be shown to the end user. Essentially, they have permission to see the message, but won't because harrasing an end user with debug messages is not a friendly thing to do.</p>
<h2 id="bonus-adding-detail">Bonus: Adding Detail</h2>
<p>There is also wrapper called <code>wrap_UR_detail</code> that adds a table of strings to a UR called <code>detail</code>. The purpose of this is to allow more sophisticated logging and handling of events. Of course, adding such support also increases the overhead of UR; so please take that into consideration.</p>
<p>Building on the earlier example for logging:</p>
<pre class="nim"><code>import
  strutils,
  logging

import
  ur,
  urpkg.log

var L = newFileLogger(&quot;test.log&quot;, fmtStr = verboseFmtStr)
addHandler(L)


type
  Vector = tuple[x: float, y: float]


wrap_UR_detail(Vector)

proc example(v: Vector, category: string): UR_Vector:
  result = newUR_Vector()
  result.value = v
  result.value.x = result.value.x + 1.0
  result.set_expected_success(&quot;x incremented by 1.0&quot;)
  result.detail[&quot;category&quot;] = category

var a = Vector(x: 9.3, y: 3.0)

var response = a.example(&quot;project abc&quot;)

echo &quot;message: $1, category: $2&quot;.format(response.msg, response.detail[&quot;category&quot;])
</code></pre>
<p>To use the detail in the context of <code>urpkg.log</code>, there is a procedure called <code>setURLogFormat</code>. It is expecting a pointer to a procedure. That procedure <em>must</em> have the following parameters:</p>
<pre class="nim"><code>(event: UREvent, detail: Table[string, string]): string</code></pre>
<p>So, for example:</p>
<pre class="nim"><code>var L = newFileLogger(&quot;test.log&quot;, fmtStr = verboseFmtStr)
addHandler(L)

proc my_example_format(event: UREvent, detail: Table[string, string]): string =
  var category = &quot;unknown&quot;
  if detail.hasKey(&quot;category&quot;):
    category = detail[&quot;category&quot;]
  result = &quot;[$1] [$2] $3&quot;.format(event.class, category, event.msg)

setURLogFormat(my_example_format)
</code></pre>
<p>Now, the entry in &quot;test.log&quot; will look like:</p>
<pre class="log"><code>D, [2018-06-29T12:34:42] -- app: [success] [project abc] x incremented by 1.0</code></pre>
<p>NOTE: the <code>setURLLogFormat</code> procedure also works with the simpler <code>wrap_UR</code>. The <code>detail</code> table will simply be empty.</p>
<h2 id="more-information">More Information</h2>
<p>Additional references and articles:</p>
<ul>
<li><a href="ur.html">module documentation: ur</a></li>
<li><a href="ur.html">module documentation: urpkg.log</a></li>
</ul>
</body>
</html>
