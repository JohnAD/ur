# ur
## Nim Universal Return system

A Universal Return (UR) is an object that allows the programmer to return either
a value or a sequence of messages (or both) from a procedure. This could, of course,
be done by hand using tuple or other options, but the goal of this package is
two-fold:

1. Make it easy (and predictable) to create such "dynamic" returns.
2. Make it possible to integrate such a system with other libraries.

## A Simple Example

The following is a very simple example of UR.

First, we are going to import the library and "wrap" the type of element we want
to return.

```nim
import ur


type
  Vector = tuple[x: int, y: int]


wrap_UR(Vector)

```

The `wrap_UR` macro applies a large number of methods to the `Vector` tuple. And it creates a
`UR_Vector` object for the UR function.

(Don't worry, with conditional compiling, Nim should later remove the ones you don't use.)

Now, we use it for returning a flexible result:

```nim
import ur


type
  Vector = tuple[x: float, y: float]


wrap_UR(Vector)

proc reduceXByNumber(v: Vector, denominator: float): UR_Vector =
  result = newUR_Vector()  # this procedure was generated by 'wrap_UR'
  if denominator == 0.0:
    result.set_failure("You can't divide by zero; Ever")
    return
  if denominator == 0.0:
    result.set_failure("Negative denominators are not allowed")
    return
  if denominator < 0.1:
    result.set_warning("That is an awefully small denominator")
  newVector = v
  newVector.x = newVector.x / denominator
  result.value = newVector
  result.set_expected_success("Vector x reduced")


# Now lets use it.

var a = Vector(4.0, 3.2)

var response = reduceXByNumber(a, 2.0)
if response.ok:
  echo "my new x is " & $response.value.x

# should display:
#
# > my new x is 2.0


response = reduceXByNumber(a, 0.0)
if not response.ok:
  echo "error messages: " & $response

# should display:
#
# error messages:
#...... TODO

response = reduceXByNumber(a, 0.0001)
if response.ok:
  echo "my new x is " & $response.value.x
if response.has_warnings:
  echo "my warnings are " & $response.warnings

# should display:
#
#.....TODO

#


```

## An example of integration with another library

Internally, UR has one library already integrated: logger.

For example:

xx TODO

## the UR Object in Detail:

The object is defined internally as:

```nim
type

  URevent*
    msg*: string                     
    level*: Level                    
    class*: DisplayClass             
    audience*: Audience 

  UR_<type>
    events*: seq[URevent]
    value*: <type>
```

So, essentially, there is a list of events (messages) and the value being returned.

Each event has a message and three very distinct attributes.

### level

The level is the degree of distribution for the message.

It answers the question: *How Important is This?*

The available levels:

* `lvlAll`
* `lvlDebug`
* `lvlInfo`
* `lvlNotice`
* `lvlWarn`
* `lvlError`
* `lvlFatal`
* `lvlNone`

The level definitions are set by the `logger` library that is part of Nim's standard level. See: X

NOTE: the names of the levels are somewhat misleading. Using a level of `lvlError` does NOT mean that an error has occured. It means *"if I'm filtering a log for mostly errors, this message should show up in that log"*.

For judging the character of the event, use the `class`.

### class

The class is the judgement of the event.

it answers the question: *Is this a good or bad event?*

Only four classes are possible:

* `info` - a neutral message adding extra information
* `success` - everything worked
* `warning` - everything worked, but something is suspicious
* `danger` - failure/error/bug

The class definitions are from the Boostrap CSS project. See: https://getbootstrap.com

### audience

The audience is, not surpisingly, the intended audience for any message about the event.

In a traditional 'logger' or SYSLOG system, the intended audience is strictly `ops`. This system allows the further levels; useful when UR is integrated with web apps or other development frameworks.

It answers the question: *Who is permitted to see This?*

The possible audiences are:

* `ops` - IT, Developers, system software
* `admin` - users with admin clearance
* `user` - regular end users / registered members
* `public` - the whole world (no restrictions)

Each audience permission is more restrictive than the previous. So, `ops` can see all events. But `admin` can only see 'admin', 'user' and 'public events. And so on.

### Combining the attributes together.

The attributes are meant to be combined when making decisions.

For example, an event with a audience of 'user' but a level of 'lvlDebug' probably won't be shown to the user. Essentially, they have permission to see the message, but won't because harrasing an end-user with debug messages is not a friendly thing to do.
